这一步我们不再停留在“概念设计”，而是直接把
「八字 × 社会周期 × 人生K线」的融合算法
做成 可在你现有小程序 utils 层直接落地的工程级方案。

下面我会按 “从理论 → 模型 → 可执行代码结构” 的顺序来做，而且每一层都明确：

✅ 输入是什么

✅ 输出是什么

✅ 为什么这样设计

✅ 在端侧如何跑得动

一、整体融合算法的“总结构图”（你要的第2项核心）

我们定义最终的人生 K 线值为：

LifeK
(
𝑡
)
=
𝐹
𝐵
𝑎
𝑍
𝑖
(
𝑡
)
⏟
个人内因
×
𝐹
𝑆
𝑜
𝑐
𝑖
𝑒
𝑡
𝑦
(
𝑡
)
⏟
时代外因
×
𝐹
𝑃
ℎ
𝑎
𝑠
𝑒
(
𝑡
)
⏟
年龄阶段修正
LifeK(t)=
个人内因
F
BaZi
	​

(t)
	​

	​

×
时代外因
F
Society
	​

(t)
	​

	​

×
年龄阶段修正
F
Phase
	​

(t)
	​

	​


⚠️ 注意：

不是简单加法

用乘法是为了体现“个人再强，也会被时代放大/压制”

二、模块 1：八字 → 个人运势基线函数 F_BaZi(t)
2.1 八字在工程里的“可计算表达”

我们不做玄学解释，而是数值化：

① 八字结构（已在你 utils/bazi）
{
  year: { tg: '甲', dz: '子' },
  month:{ tg: '丙', dz: '寅' },
  day:  { tg: '戊', dz: '午' },   // 日主
  hour: { tg: '庚', dz: '申' }
}

② 五行映射（量化）
const WUXING_VALUE = {
  木: 1.0,
  火: 1.1,
  土: 1.0,
  金: 0.9,
  水: 0.95
}

③ 日主强弱计算（核心）
function calcDayStrength(bazi) {
  let score = 1.0
  score += WUXING_VALUE[bazi.month.dzWuxing] * 0.4
  score += WUXING_VALUE[bazi.hour.dzWuxing] * 0.2
  score -= WUXING_VALUE[bazi.year.dzWuxing] * 0.1
  return clamp(score, 0.6, 1.4)
}


👉 这个 score 就是个人长期基线能力

2.2 大运 / 流年 → 时间函数
大运周期（10年）
function daYunFactor(age) {
  return 1 + Math.sin(age / 10 * Math.PI) * 0.15
}

流年波动（1年）
function liuNianFactor(age) {
  return 1 + Math.sin(age * 1.3) * 0.05
}

合成八字因子
export function calcBaZiFactor(age, bazi) {
  const base = calcDayStrength(bazi)
  return base * daYunFactor(age) * liuNianFactor(age)
}


✅ 输出：0.7 ~ 1.6 的连续值

三、模块 2：社会周期函数 F_Society(t)（这是你之前缺失的核心）
3.1 为什么必须单独建模？

因为：

同样的八字

在 1978 / 2008 / 2025 / 2040
结果完全不同

3.2 社会周期三层结构（工程化）
SocietyFactor = 
  LongCycle × MidCycle × ShortShock

① 长周期（康波 / 技术范式）
function longCycle(year) {
  // 50~60年
  return 1 + Math.sin((year - 1980) / 55 * Math.PI) * 0.25
}

② 中周期（经济 / 产业）
function midCycle(year) {
  // 8~12年
  return 1 + Math.sin((year - 2000) / 10 * Math.PI) * 0.15
}

③ 短期冲击（疫情、金融危机）
const SHOCKS = {
  2008: -0.3,
  2020: -0.25
}

function shortShock(year) {
  return SHOCKS[year] ? 1 + SHOCKS[year] : 1
}

社会周期合成
export function calcSocietyFactor(year) {
  return clamp(
    longCycle(year) * midCycle(year) * shortShock(year),
    0.6,
    1.5
  )
}

四、模块 3：人生阶段修正 F_Phase(t)

这个是 避免“幼年K线乱飞”的关键

function phaseFactor(age) {
  if (age < 18) return 0.6
  if (age < 25) return 0.85
  if (age < 40) return 1.1
  if (age < 55) return 1.0
  return 0.9
}

五、最终融合算法（你要的“第2项”核心）
import { calcBaZiFactor } from './bazi-engine'
import { calcSocietyFactor } from './society-engine'

export function calcLifeKlinePoint(age, year, bazi) {
  const bz = calcBaZiFactor(age, bazi)
  const soc = calcSocietyFactor(year)
  const phase = phaseFactor(age)

  return clamp(bz * soc * phase, 0.3, 2.0)
}

六、直接生成 K 线（对接你已有 Canvas）
export function generateLifeKline(bazi, birthYear) {
  const arr = []
  for (let age = 0; age <= 80; age++) {
    const year = birthYear + age
    arr.push({
      age,
      year,
      value: calcLifeKlinePoint(age, year, bazi)
    })
  }
  return arr
}

七、这套算法 为什么“能上线”
维度	说明
端侧性能	O(N)，80点毫秒级
可解释性	每个因子可拆
合规	明确“趋势分析”
可升级	可换权重
商业化	高阶参数可付费
